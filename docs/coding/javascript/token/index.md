# 前端存储Token方案

## 一、JWT

JWT 的全称是 JSON Web Token。它是一种开放标准（RFC 7519），定义了一种紧凑且自包含的方式，用于在各方之间作为 JSON 对象安全地传输信息。

你可以把它理解为一个 `数字凭证`，这个凭证可以被验证和信任，因为它经过了 `数字签名`。

### 1.1、JWT解决什么问题？

在传统 Web 开发中，服务端通过 Session 和 Cookie 记录用户的登录状态。这种方式存在一些问题：

1. 扩展性问题：在分布式和微服务架构中，Session需要共享，否则用户可能需要在不同服务器上重新登录。通常需要引入 Redis 等外部存储来实现 Session 共享，增加了复杂性。
2. CSRF风险：基于 Cookie 的方式容易受到跨站请求伪造（CSRF）攻击，需要额外的手段来防护。

JWT 的出现就是为了解决这些痛点，它的核心思想是：将用户状态数据直接返回给客户端，由客户端存储，服务端不再保存。服务端只需验证收到的 Token 是否有效和可信即可。这种方式实现了服务的「无状态化」，使得应用更容易扩展。

### 1.2、JWT 的组成结构

一个 JWT 看起来是一长串字符串，中间用点（`.`）分隔成三个部分，格式为：`Header.Payload.Signature`。例如：

```tex
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

#### 1.2.1、Header (头部)

头部通常由两部分组成：

- `typ`：令牌类型，就是 `JWT`
- `alg`：签名算法，如 `HMAC SHA256` 或 `RSA`

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

这个 JSON 对象会被 `Base64` 编码，形成 JWT 的第一部分。

#### 1.2.2、Payload (负载)

负载部分包含了你要传递的声名（Claims），声明是关于实体（通常是用户）和其他数据的语句。有三种类型的声明：

+ 注册声明：预定义的声明，例如：`iss`（发行者）、`exp`（过期时间）、`sub`（主题）等
+ 公共声明：自定义声明，应避免冲突，可在 IANA JSON Web Token Registry 注册
+ 私有声明：用于特定应用之间共享信息

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "admin": true
}
```

🔔注意：Payload 内容只是经过 Base64Url 编码，并没有加密，所以不要在其中存放敏感信息（如密码）。

#### 1.2.3、Signature (签名)

签名部分是整个 Token 的核心，用于防止数据被篡改。

生成签名的过程如下：

1. 取编码后的 Header
2. 取编码后的 Payload
3. 用一个秘密（Secret）（如果使用 HMAC SHA256 算法）或者一个私钥（如果使用 RSA 算法）
4. 用 Header 中指定的算法（如 HS256）进行签名。

### 1.3、JWT认证流程

![image-20250917141253343](images/image-20250917141253343.png)

### 1.4、JWT与Redis的使用案例

JWT 中一般不会存储用户信息，主要是为了防止 token 被窃取之后破解。

在用户登录之后将 `用户id 或（uuid）` 作为 Redis 的 key，用户信息作为 value 存储在 Redis 中，`用户id` 作为 jwt 的 Payload 的生成 token 返回给前端。

JWT 与 Redis 的运用需要根据实际的登录流程和需求进行设计。

### 1.5、JWT 的优点与缺点

| 优点           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 无状态与可扩展 | 服务端不需要存储 Session，Token 自身包含了所有用户信息。这使得应用很容易水平扩展，非常适合分布式和微服务架构。 |
| 跨域友好       | 由于不依赖 Cookie，可以轻松解决跨域问题（CORS），非常适合单页应用（SPA）与后端 API 的交互。 |
| 多端适用       | 同样因为不依赖 Cookie，它在移动端（App）和非浏览器环境下（如小程序）也能很好地工作。 |
| 灵活性         | Payload 可以自定义丰富的信息，减少数据库查询次数。           |

| 缺点             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| Token 无法撤销   | 一旦签发，在到期之前会一直有效。除非服务端增加额外的逻辑（如黑名单机制）来使其失效。 |
| 安全性依赖客户端 | Token 由客户端存储，如果存储不当（如存在 XSS 漏洞的 JS 可以读取 localStorage），有被盗用的风险。 |
| 性能问题         | Payload 内容过多会导致 Token 体积变大，每次请求都会携带，增加网络开销。 |
| 非加密性         | Payload 只是编码，不是加密，不能存放敏感信息。               |

## 二、存储Token方案

### 2.1、将 Token 存储在LocalStorge

前端获取到的 token 存储在 LocalStorge 时，如果Web应用存在 XSS 漏洞，攻击者可以通过 `localStorage.getItem('token')` 或直接访问 Vuex 状态库或 Redux 状态库的状态来窃取 token，然后就能以其权限调用任何 API。

如果不了解 XSS攻击原理，可以详细见 [XSS攻击](./xss)

虽然这种方式存储无法防御 XSS 攻击，但这仍然是主流的安全实践。

当前方案虽然不对 XSS 免疫，但是做出做出了一个更清晰、更可控的 `安全边界划分`。该方案将 XSS 是一个必须被修复的漏洞，而不是一个被 "绕过去" 的问题。职责将 `防御XSS` 和 `防御认证凭证被盗` 的责任完全分开

当前方案还可以 `彻底消除CSRF风险`，因为不依赖自动发送的Cookie，所以天然免疫CSRF攻击。这是它的一个巨大优势。

当前方案必须使用 https 来保证 token 不被数据截获、中间人攻击以及会话劫持

### 2.2、将Token存储在Cookie中

后端将生成的 token 存入 Cookie 中，这里不是前端存入主要是前端将设置 Cookie 的 HttpOnly 并不生效。所以让后端生成 token 存入 Cookie 并开启 HttpOnly 。

该种方案的 Cookie 无法被 JavaScript 读取，即使页面被注入恶意脚本（XSS），攻击者无法窃取 token 。

由于浏览器会自动携带 Cookie，即使请求来自第三方网站，所有该种方案有 CSRF 风险。可以使用 Cookie 的 SameSite 属性来有效降低 CSRF 风险，但不是绝对的，需要配合其他方案进行处理。